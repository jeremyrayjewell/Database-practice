"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PSDB = void 0;
const https = require("https");
const mysql = require("mysql2");
const nanoid_1 = require("nanoid");
const crypto = require("crypto");
const webcrypto_1 = require("@peculiar/webcrypto");
const x509 = require("@peculiar/x509");
let webcrypto = crypto.webcrypto;
if (crypto.webcrypto == undefined) {
    console.warn('No native webcrypto available, using @peculiar/webcrypto polyfill. Please upgrade to Node 15 or later to avoid this warning.');
    webcrypto = new webcrypto_1.Crypto();
}
x509.cryptoProvider.set(webcrypto);
const nanoid = nanoid_1.customAlphabet('0123456789abcdefghijklmnopqrstuvwxyz', 12);
const nodeBtoa = (str) => Buffer.from(str, 'binary').toString('base64');
const base64encode = typeof btoa !== 'undefined' ? btoa : nodeBtoa;
class PSDB {
    constructor(branch = 'main', connectionOptions = {}) {
        this._connection = null;
        this.branch = branch;
        this._tokenname = process.env.PLANETSCALE_TOKEN_NAME;
        this._token = process.env.PLANETSCALE_TOKEN;
        this._org = process.env.PLANETSCALE_ORG;
        this._db = process.env.PLANETSCALE_DB;
        this._baseURL = 'https://api.planetscale.com';
        this._headers = { Authorization: `${this._tokenname}:${this._token}` };
        this.connectionOptions = connectionOptions;
    }
    async query(data, params) {
        if (!this._connection) {
            this._connection = await this.createConnection();
        }
        return this._connection.promise().query(data, params);
    }
    async execute(sql, values) {
        if (!this._connection) {
            this._connection = await this.createConnection();
        }
        return this._connection.promise().execute(sql, values);
    }
    async createConnection() {
        const alg = {
            name: 'ECDSA',
            namedCurve: 'P-256',
            hash: 'SHA-256'
        };
        const keyPair = await webcrypto.subtle.generateKey(alg, true, ['sign', 'verify']);
        if (!keyPair.privateKey) {
            throw new Error('Failed to generate keypair');
        }
        const csr = await x509.Pkcs10CertificateRequestGenerator.create({
            keys: keyPair,
            signingAlgorithm: alg
        });
        const fullURL = new URL(`${this._baseURL}/v1/organizations/${this._org}/databases/${this._db}/branches/${this.branch}/certificates`);
        const displayName = `pscale-node-${nanoid()}`;
        const { response, body } = await postJSON(fullURL, this._headers, {
            csr: csr.toString(),
            display_name: displayName
        });
        const status = response.statusCode || 0;
        if (status < 200 || status > 299) {
            throw new Error(`HTTP ${status}`);
        }
        const addr = body.database_branch.access_host_url;
        const exportPrivateKey = await webcrypto.subtle.exportKey('pkcs8', keyPair.privateKey);
        const exportedAsString = String.fromCharCode.apply(null, Array.from(new Uint8Array(exportPrivateKey)));
        const exportedAsBase64 = base64encode(exportedAsString);
        const pemExported = `-----BEGIN PRIVATE KEY-----\n${exportedAsBase64}\n-----END PRIVATE KEY-----`;
        return mysql.createConnection({
            ...this.connectionOptions,
            user: body.id,
            host: addr,
            database: this._db,
            ssl: {
                key: pemExported,
                cert: body.certificate,
                rejectUnauthorized: true
            }
        });
    }
}
exports.PSDB = PSDB;
function postJSON(url, headers, body) {
    const json = JSON.stringify(body);
    const options = {
        hostname: url.host,
        port: 443,
        path: url.pathname,
        method: 'POST',
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
            'Content-Length': json.length,
            'User-Agent': 'planetscale-node/0.2.0',
            ...headers
        }
    };
    return new Promise((resolve, reject) => {
        const req = https.request(options, (response) => {
            let body = '';
            response.on('data', (chunk) => (body += chunk));
            response.on('end', () => resolve({ response, body: JSON.parse(body) }));
        });
        req.on('error', (e) => reject(e));
        req.write(json);
        req.end();
    });
}
